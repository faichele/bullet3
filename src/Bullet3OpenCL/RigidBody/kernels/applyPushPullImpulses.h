//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* applyPushPullImpulsesCL= \
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"#ifndef B3_RIGIDBODY_DATA_H\n"
"#define B3_RIGIDBODY_DATA_H\n"
"#ifndef B3_FLOAT4_H\n"
"#define B3_FLOAT4_H\n"
"#ifndef B3_PLATFORM_DEFINITIONS_H\n"
"#define B3_PLATFORM_DEFINITIONS_H\n"
"struct MyTest\n"
"{\n"
"	int bla;\n"
"};\n"
"#ifdef __cplusplus\n"
"#else\n"
"//keep B3_LARGE_FLOAT*B3_LARGE_FLOAT < FLT_MAX\n"
"#define B3_LARGE_FLOAT 1e18f\n"
"#define B3_INFINITY 1e18f\n"
"#define b3Assert(a)\n"
"#define b3ConstArray(a) __global const a *\n"
"#define b3AtomicInc atomic_inc\n"
"#define b3AtomicAdd atomic_add\n"
"#define b3Fabs fabs\n"
"#define b3Sqrt native_sqrt\n"
"#define b3Sin native_sin\n"
"#define b3Cos native_cos\n"
"#define B3_STATIC\n"
"#endif\n"
"#endif\n"
"#ifdef __cplusplus\n"
"#else\n"
"typedef float4 b3Float4;\n"
"#define b3Float4ConstArg const b3Float4\n"
"#define b3MakeFloat4 (float4)\n"
"float b3Dot3F4(b3Float4ConstArg v0, b3Float4ConstArg v1)\n"
"{\n"
"	float4 a1 = b3MakeFloat4(v0.xyz, 0.f);\n"
"	float4 b1 = b3MakeFloat4(v1.xyz, 0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"b3Float4 b3Cross3(b3Float4ConstArg v0, b3Float4ConstArg v1)\n"
"{\n"
"	float4 a1 = b3MakeFloat4(v0.xyz, 0.f);\n"
"	float4 b1 = b3MakeFloat4(v1.xyz, 0.f);\n"
"	return cross(a1, b1);\n"
"}\n"
"#define b3MinFloat4 min\n"
"#define b3MaxFloat4 max\n"
"#define b3Normalized(a) normalize(a)\n"
"#endif\n"
"inline bool b3IsAlmostZero(b3Float4ConstArg v)\n"
"{\n"
"	if (b3Fabs(v.x) > 1e-6 || b3Fabs(v.y) > 1e-6 || b3Fabs(v.z) > 1e-6)\n"
"		return false;\n"
"	return true;\n"
"}\n"
"inline int b3MaxDot(b3Float4ConstArg vec, __global const b3Float4* vecArray, int vecLen, float* dotOut)\n"
"{\n"
"	float maxDot = -B3_INFINITY;\n"
"	int i = 0;\n"
"	int ptIndex = -1;\n"
"	for (i = 0; i < vecLen; i++)\n"
"	{\n"
"		float dot = b3Dot3F4(vecArray[i], vec);\n"
"		if (dot > maxDot)\n"
"		{\n"
"			maxDot = dot;\n"
"			ptIndex = i;\n"
"		}\n"
"	}\n"
"	b3Assert(ptIndex >= 0);\n"
"	if (ptIndex < 0)\n"
"	{\n"
"		ptIndex = 0;\n"
"	}\n"
"	*dotOut = maxDot;\n"
"	return ptIndex;\n"
"}\n"
"#endif  //B3_FLOAT4_H\n"
"#ifndef B3_QUAT_H\n"
"#define B3_QUAT_H\n"
"#ifndef B3_PLATFORM_DEFINITIONS_H\n"
"#ifdef __cplusplus\n"
"#else\n"
"#endif\n"
"#endif\n"
"#ifndef B3_FLOAT4_H\n"
"#ifdef __cplusplus\n"
"#else\n"
"#endif\n"
"#endif  //B3_FLOAT4_H\n"
"#ifdef __cplusplus\n"
"#else\n"
"typedef float4 b3Quat;\n"
"#define b3QuatConstArg const b3Quat\n"
"inline float4 b3FastNormalize4(float4 v)\n"
"{\n"
"	v = (float4)(v.xyz, 0.f);\n"
"	return fast_normalize(v);\n"
"}\n"
"inline b3Quat b3QuatMul(b3Quat a, b3Quat b);\n"
"inline b3Quat b3QuatNormalized(b3QuatConstArg in);\n"
"inline b3Quat b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec);\n"
"inline b3Quat b3QuatInvert(b3QuatConstArg q);\n"
"inline b3Quat b3QuatInverse(b3QuatConstArg q);\n"
"inline b3Quat b3QuatMul(b3QuatConstArg a, b3QuatConstArg b)\n"
"{\n"
"	b3Quat ans;\n"
"	ans = b3Cross3(a, b);\n"
"	ans += a.w * b + b.w * a;\n"
"	//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w * b.w - b3Dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"inline b3Quat b3QuatNormalized(b3QuatConstArg in)\n"
"{\n"
"	b3Quat q;\n"
"	q = in;\n"
"	//return b3FastNormalize4(in);\n"
"	float len = native_sqrt(dot(q, q));\n"
"	if (len > 0.f)\n"
"	{\n"
"		q *= 1.f / len;\n"
"	}\n"
"	else\n"
"	{\n"
"		q.x = q.y = q.z = 0.f;\n"
"		q.w = 1.f;\n"
"	}\n"
"	return q;\n"
"}\n"
"inline float4 b3QuatRotate(b3QuatConstArg q, b3QuatConstArg vec)\n"
"{\n"
"	b3Quat qInv = b3QuatInvert(q);\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = b3QuatMul(b3QuatMul(q, vcpy), qInv);\n"
"	return out;\n"
"}\n"
"inline b3Quat b3QuatInverse(b3QuatConstArg q)\n"
"{\n"
"	return (b3Quat)(-q.xyz, q.w);\n"
"}\n"
"inline b3Quat b3QuatInvert(b3QuatConstArg q)\n"
"{\n"
"	return (b3Quat)(-q.xyz, q.w);\n"
"}\n"
"inline float4 b3QuatInvRotate(b3QuatConstArg q, b3QuatConstArg vec)\n"
"{\n"
"	return b3QuatRotate(b3QuatInvert(q), vec);\n"
"}\n"
"inline b3Float4 b3TransformPoint(b3Float4ConstArg point, b3Float4ConstArg translation, b3QuatConstArg orientation)\n"
"{\n"
"	return b3QuatRotate(orientation, point) + (translation);\n"
"}\n"
"#endif\n"
"#endif  //B3_QUAT_H\n"
"#ifndef B3_MAT3x3_H\n"
"#define B3_MAT3x3_H\n"
"#ifndef B3_QUAT_H\n"
"#ifdef __cplusplus\n"
"#else\n"
"#endif\n"
"#endif  //B3_QUAT_H\n"
"#ifdef __cplusplus\n"
"#else\n"
"typedef struct\n"
"{\n"
"	b3Float4 m_row[3];\n"
"} b3Mat3x3;\n"
"#define b3Mat3x3ConstArg const b3Mat3x3\n"
"#define b3GetRow(m, row) (m.m_row[row])\n"
"inline b3Mat3x3 b3QuatGetRotationMatrix(b3Quat quat)\n"
"{\n"
"	b3Float4 quat2 = (b3Float4)(quat.x * quat.x, quat.y * quat.y, quat.z * quat.z, 0.f);\n"
"	b3Mat3x3 out;\n"
"	out.m_row[0].x = 1 - 2 * quat2.y - 2 * quat2.z;\n"
"	out.m_row[0].y = 2 * quat.x * quat.y - 2 * quat.w * quat.z;\n"
"	out.m_row[0].z = 2 * quat.x * quat.z + 2 * quat.w * quat.y;\n"
"	out.m_row[0].w = 0.f;\n"
"	out.m_row[1].x = 2 * quat.x * quat.y + 2 * quat.w * quat.z;\n"
"	out.m_row[1].y = 1 - 2 * quat2.x - 2 * quat2.z;\n"
"	out.m_row[1].z = 2 * quat.y * quat.z - 2 * quat.w * quat.x;\n"
"	out.m_row[1].w = 0.f;\n"
"	out.m_row[2].x = 2 * quat.x * quat.z - 2 * quat.w * quat.y;\n"
"	out.m_row[2].y = 2 * quat.y * quat.z + 2 * quat.w * quat.x;\n"
"	out.m_row[2].z = 1 - 2 * quat2.x - 2 * quat2.y;\n"
"	out.m_row[2].w = 0.f;\n"
"	return out;\n"
"}\n"
"inline b3Mat3x3 b3AbsoluteMat3x3(b3Mat3x3ConstArg matIn)\n"
"{\n"
"	b3Mat3x3 out;\n"
"	out.m_row[0] = fabs(matIn.m_row[0]);\n"
"	out.m_row[1] = fabs(matIn.m_row[1]);\n"
"	out.m_row[2] = fabs(matIn.m_row[2]);\n"
"	return out;\n"
"}\n"
"__inline b3Mat3x3 mtZero();\n"
"__inline b3Mat3x3 mtIdentity();\n"
"__inline b3Mat3x3 mtTranspose(b3Mat3x3 m);\n"
"__inline b3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b);\n"
"__inline b3Float4 mtMul1(b3Mat3x3 a, b3Float4 b);\n"
"__inline b3Float4 mtMul3(b3Float4 a, b3Mat3x3 b);\n"
"__inline b3Mat3x3 mtZero()\n"
"{\n"
"	b3Mat3x3 m;\n"
"	m.m_row[0] = (b3Float4)(0.f);\n"
"	m.m_row[1] = (b3Float4)(0.f);\n"
"	m.m_row[2] = (b3Float4)(0.f);\n"
"	return m;\n"
"}\n"
"__inline b3Mat3x3 mtIdentity()\n"
"{\n"
"	b3Mat3x3 m;\n"
"	m.m_row[0] = (b3Float4)(1, 0, 0, 0);\n"
"	m.m_row[1] = (b3Float4)(0, 1, 0, 0);\n"
"	m.m_row[2] = (b3Float4)(0, 0, 1, 0);\n"
"	return m;\n"
"}\n"
"__inline b3Mat3x3 mtTranspose(b3Mat3x3 m)\n"
"{\n"
"	b3Mat3x3 out;\n"
"	out.m_row[0] = (b3Float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\n"
"	out.m_row[1] = (b3Float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\n"
"	out.m_row[2] = (b3Float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\n"
"	return out;\n"
"}\n"
"__inline b3Mat3x3 mtMul(b3Mat3x3 a, b3Mat3x3 b)\n"
"{\n"
"	b3Mat3x3 transB;\n"
"	transB = mtTranspose(b);\n"
"	b3Mat3x3 ans;\n"
"	//	why this doesn't run when 0ing in the for{}\n"
"	a.m_row[0].w = 0.f;\n"
"	a.m_row[1].w = 0.f;\n"
"	a.m_row[2].w = 0.f;\n"
"	for (int i = 0; i < 3; i++)\n"
"	{\n"
"		//	a.m_row[i].w = 0.f;\n"
"		ans.m_row[i].x = b3Dot3F4(a.m_row[i], transB.m_row[0]);\n"
"		ans.m_row[i].y = b3Dot3F4(a.m_row[i], transB.m_row[1]);\n"
"		ans.m_row[i].z = b3Dot3F4(a.m_row[i], transB.m_row[2]);\n"
"		ans.m_row[i].w = 0.f;\n"
"	}\n"
"	return ans;\n"
"}\n"
"__inline b3Float4 mtMul1(b3Mat3x3 a, b3Float4 b)\n"
"{\n"
"	b3Float4 ans;\n"
"	ans.x = b3Dot3F4(a.m_row[0], b);\n"
"	ans.y = b3Dot3F4(a.m_row[1], b);\n"
"	ans.z = b3Dot3F4(a.m_row[2], b);\n"
"	ans.w = 0.f;\n"
"	return ans;\n"
"}\n"
"__inline b3Float4 mtMul3(b3Float4 a, b3Mat3x3 b)\n"
"{\n"
"	b3Float4 colx = b3MakeFloat4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\n"
"	b3Float4 coly = b3MakeFloat4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\n"
"	b3Float4 colz = b3MakeFloat4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\n"
"	b3Float4 ans;\n"
"	ans.x = b3Dot3F4(a, colx);\n"
"	ans.y = b3Dot3F4(a, coly);\n"
"	ans.z = b3Dot3F4(a, colz);\n"
"	return ans;\n"
"}\n"
"#endif\n"
"#endif  //B3_MAT3x3_H\n"
"typedef struct b3RigidBodyData b3RigidBodyData_t;\n"
"struct b3RigidBodyData\n"
"{\n"
"	b3Float4 m_pos;\n"
"	b3Quat m_quat;\n"
"	b3Float4 m_linVel;\n"
"	b3Float4 m_angVel;\n"
"	int m_collidableIdx;\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"};\n"
"typedef struct b3InertiaData b3InertiaData_t;\n"
"struct b3InertiaData\n"
"{\n"
"	b3Mat3x3 m_invInertiaWorld;\n"
"	b3Mat3x3 m_initInvInertia;\n"
"};\n"
"#endif  //B3_RIGIDBODY_DATA_H\n"
"#ifndef B3_RIGIDBODY_BEHAVIOR_H\n"
"#define B3_RIGIDBODY_BEHAVIOR_H\n"
"#ifndef B3_FLOAT4_H\n"
"#ifdef __cplusplus\n"
"#else\n"
"#endif\n"
"#endif  //B3_FLOAT4_H\n"
"#ifndef B3_QUAT_H\n"
"#ifdef __cplusplus\n"
"#else\n"
"#endif\n"
"#endif  //B3_QUAT_H\n"
"#define B3_RIGID_BODY_BEHAVIOR_MAX_CONTACTS 10\n"
"typedef struct b3RigidBodyPushPullBehavior b3RigidBodyPushPullBehavior_t;\n"
"struct b3RigidBodyPushPullBehavior\n"
"{\n"
"	int m_bodyID;\n"
"	int m_ghostObjectID;\n"
"	b3Float4 m_bodyPosition;  // Should not be needed, but ConcaveScene demo operates with mesh offsets instead of actual origin transforms.\n"
"	b3Quat m_bodyOrientation;\n"
"	bool m_perContactPoint;\n"
"	b3Float4 m_linearAcc;\n"
"	b3Float4 m_angularAcc;\n"
"	/*b3RigidBodyPushPullBehavior()\n"
"	{\n"
"		m_bodyID = -1;\n"
"		m_ghostObjectID = -1;\n"
"		m_bodyPosition = b3MakeFloat4(0, 0, 0, 0);\n"
"		m_bodyOrientation = b3Quaternion(0, 0, 0, 1);\n"
"		m_linearAcc = b3MakeFloat4(0, 0, 0, 0);\n"
"		m_angularAcc = b3MakeFloat4(0, 0, 0, 0);\n"
"		m_perContactPoint = false;\n"
"	}\n"
"	b3RigidBodyPushPullBehavior(const b3RigidBodyPushPullBehavior& other)\n"
"	{\n"
"		if (this != &other)\n"
"		{\n"
"			m_bodyID = other.m_bodyID;\n"
"			m_ghostObjectID = other.m_ghostObjectID;\n"
"			m_perContactPoint = other.m_perContactPoint;\n"
"			m_bodyPosition.x = other.m_bodyPosition.x;\n"
"			m_bodyPosition.y = other.m_bodyPosition.y;\n"
"			m_bodyPosition.z = other.m_bodyPosition.z;\n"
"			m_bodyPosition.w = other.m_bodyPosition.w;\n"
"			m_linearAcc.x = other.m_linearAcc.x;\n"
"			m_linearAcc.y = other.m_linearAcc.y;\n"
"			m_linearAcc.z = other.m_linearAcc.z;\n"
"			m_linearAcc.w = other.m_linearAcc.w;\n"
"			m_angularAcc.x = other.m_angularAcc.x;\n"
"			m_angularAcc.y = other.m_angularAcc.y;\n"
"			m_angularAcc.z = other.m_angularAcc.z;\n"
"			m_angularAcc.w = other.m_angularAcc.w;\n"
"			m_bodyOrientation.x = other.m_bodyOrientation.x;\n"
"			m_bodyOrientation.y = other.m_bodyOrientation.y;\n"
"			m_bodyOrientation.z = other.m_bodyOrientation.z;\n"
"			m_bodyOrientation.w = other.m_bodyOrientation.w;\n"
"		}\n"
"	}\n"
"	b3RigidBodyPushPullBehavior& operator=(const b3RigidBodyPushPullBehavior& other)\n"
"	{\n"
"		if (this != &other)\n"
"		{\n"
"			m_bodyID = other.m_bodyID;\n"
"			m_ghostObjectID = other.m_ghostObjectID;\n"
"			m_perContactPoint = other.m_perContactPoint;\n"
"			m_bodyPosition.x = other.m_bodyPosition.x;\n"
"			m_bodyPosition.y = other.m_bodyPosition.y;\n"
"			m_bodyPosition.z = other.m_bodyPosition.z;\n"
"			m_bodyPosition.w = other.m_bodyPosition.w;\n"
"			m_linearAcc.x = other.m_linearAcc.x;\n"
"			m_linearAcc.y = other.m_linearAcc.y;\n"
"			m_linearAcc.z = other.m_linearAcc.z;\n"
"			m_linearAcc.w = other.m_linearAcc.w;\n"
"			m_angularAcc.x = other.m_angularAcc.x;\n"
"			m_angularAcc.y = other.m_angularAcc.y;\n"
"			m_angularAcc.z = other.m_angularAcc.z;\n"
"			m_angularAcc.w = other.m_angularAcc.w;\n"
"			m_bodyOrientation.x = other.m_bodyOrientation.x;\n"
"			m_bodyOrientation.y = other.m_bodyOrientation.y;\n"
"			m_bodyOrientation.z = other.m_bodyOrientation.z;\n"
"			m_bodyOrientation.w = other.m_bodyOrientation.w;\n"
"		}\n"
"		return *this;\n"
"	}*/\n"
"};\n"
"typedef struct b3RigidBodyBehaviorVelocities b3RigidBodyBehaviorVelocities_t;\n"
"struct b3RigidBodyBehaviorVelocities\n"
"{\n"
"	b3Float4 m_linearAcc;\n"
"	b3Float4 m_angularAcc;\n"
"	b3Float4 m_linearVelPerContact[B3_RIGID_BODY_BEHAVIOR_MAX_CONTACTS];\n"
"	b3Float4 m_angularVelPerContact[B3_RIGID_BODY_BEHAVIOR_MAX_CONTACTS];\n"
"};\n"
"#endif\n"
"__kernel void applyPushPullImpulsesKernel(__global b3RigidBodyData_t* bodies, const int numNodes, float timeStep, float angularDamping, float4 gravityAcceleration, __global int4* collidingPairs, __global b3RigidBodyPushPullBehavior_t* pushPullBehaviors, __global b3RigidBodyBehaviorVelocities_t* pushPullVelocities, int numCollidingPairs, int numPushPullBehaviors)\n"
"{\n"
"	// Taken directly from b3IntegrateTransforms.h (integrateSingleTransform function)\n"
"	// This adds the velocities (linear and angular) for push-pull behaviors in addition to the usual integration steps per body\n"
"	int nodeID = get_global_id(0);\n"
"	if (nodeID < numNodes)\n"
"	{\n"
"		if (bodies[nodeID].m_invMass != 0.f)\n"
"		{\n"
"			// Check if there is a push-pull behavior to apply for the current body\n"
"			b3Float4 ppLinVel = b3MakeFloat4(0, 0, 0, 0);\n"
"			b3Float4 ppAngVel = b3MakeFloat4(0, 0, 0, 0);\n"
"			for (int i = 0; i < numCollidingPairs; ++i)\n"
"			{\n"
"				// First step: See which contact pairs the given nodeID matches\n"
"				if (collidingPairs[i].x == nodeID || collidingPairs[i].y == nodeID)\n"
"				{\n"
"					// Second step: See which push-pull behaviors have bodyIDs that are involved in a contact with the given nodeID\n"
"					// Sum up linear and angular velocities for all push-pull enabled bodies to be applied in one go\n"
"					for (int k = 0; k < numPushPullBehaviors; ++k)\n"
"					{\n"
"						if (pushPullBehaviors[k].m_bodyID == collidingPairs[i].x || pushPullBehaviors[k].m_bodyID == collidingPairs[i].y)\n"
"						{\n"
"							ppLinVel.x += pushPullBehaviors[k].m_linearAcc.x * timeStep;\n"
"							ppLinVel.y += pushPullBehaviors[k].m_linearAcc.y * timeStep;\n"
"							ppLinVel.z += pushPullBehaviors[k].m_linearAcc.z * timeStep;\n"
"							ppAngVel.x += pushPullBehaviors[k].m_angularAcc.x * timeStep;\n"
"							ppAngVel.y += pushPullBehaviors[k].m_angularAcc.y * timeStep;\n"
"							ppAngVel.z += pushPullBehaviors[k].m_angularAcc.z;\n"
"						}\n"
"					}\n"
"				}\n"
"			}\n"
"			float BT_GPU_ANGULAR_MOTION_THRESHOLD = (0.25f * 3.14159254f);\n"
"			//angular velocity\n"
"			{\n"
"				b3Float4 axis;\n"
"				//add some hardcoded angular damping\n"
"				bodies[nodeID].m_angVel.x *= angularDamping;\n"
"				bodies[nodeID].m_angVel.y *= angularDamping;\n"
"				bodies[nodeID].m_angVel.z *= angularDamping;\n"
"				b3Float4 angvel = bodies[nodeID].m_angVel;\n"
"				angvel.x += ppAngVel.x;\n"
"				angvel.y += ppAngVel.y;\n"
"				angvel.z += ppAngVel.z;\n"
"				\n"
"				float fAngle = b3Sqrt(b3Dot3F4(angvel, angvel));\n"
"				//limit the angular motion\n"
"				if (fAngle * timeStep > BT_GPU_ANGULAR_MOTION_THRESHOLD)\n"
"				{\n"
"					fAngle = BT_GPU_ANGULAR_MOTION_THRESHOLD / timeStep;\n"
"				}\n"
"				if (fAngle < 0.001f)\n"
"				{\n"
"					// use Taylor's expansions of sync function\n"
"					axis = angvel * (0.5f * timeStep - (timeStep * timeStep * timeStep) * 0.020833333333f * fAngle * fAngle);\n"
"				}\n"
"				else\n"
"				{\n"
"					// sync(fAngle) = sin(c*fAngle)/t\n"
"					axis = angvel * (b3Sin(0.5f * fAngle * timeStep) / fAngle);\n"
"				}\n"
"				b3Quat dorn;\n"
"				dorn.x = axis.x;\n"
"				dorn.y = axis.y;\n"
"				dorn.z = axis.z;\n"
"				dorn.w = b3Cos(fAngle * timeStep * 0.5f);\n"
"				b3Quat orn0 = bodies[nodeID].m_quat;\n"
"				b3Quat predictedOrn = b3QuatMul(dorn, orn0);\n"
"				predictedOrn = b3QuatNormalized(predictedOrn);\n"
"				bodies[nodeID].m_quat = predictedOrn;\n"
"			}\n"
"			// Record the push-pull related velocity terms for debugging\n"
"			pushPullVelocities[nodeID].m_linearAcc = ppLinVel;\n"
"			pushPullVelocities[nodeID].m_angularAcc = ppAngVel;\n"
"			// Correct order is acceleration -> velocity -> position...\n"
"			//apply gravity\n"
"			bodies[nodeID].m_linVel += gravityAcceleration * timeStep;\n"
"			// Apply push-pull behavior linear velocity if applicable: Only add once and subtract again once contact with push-pull enabled object goes away.\n"
"			bodies[nodeID].m_linVel.x += ppLinVel.x;\n"
"			bodies[nodeID].m_linVel.y += ppLinVel.y;\n"
"			bodies[nodeID].m_linVel.z += ppLinVel.z;\n"
"			//linear velocity\n"
"			bodies[nodeID].m_pos += bodies[nodeID].m_linVel * timeStep;\n"
"		}\n"
"	}\n"
"}\n"
;
